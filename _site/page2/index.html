<!DOCTYPE html>
<html lang="en">

<link href='//fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700|Comfortaa:700' rel='stylesheet' type='text/css'>
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Tinix&#39;s different point of view.</title>
  <meta name="description" content="Also known as Tinix , Degree in Computer Science FaMAF,Writer Software, Ruby, Elixir, Rust, Go, Linux and FreeBSD, I like have Mate, 4 lang​​, but all that means almost nothing..
">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:3000/page2/">
  <link rel="alternate" type="application/rss+xml" title="Tinix&#39;s different point of view." href="http://localhost:3000/feed.xml">
</head>

  <body>
      <script id="dsq-count-scr" src="//tinixgit.disqus.com/count.js" async></script>

    <header class="site-header" role="banner">
    <!-- <div class="img-responsive">
      <img src="/fondo_ruby.jpg" height="100%"; alt="head_background">
    </div> -->
    </div>

  <div class="wrapper">

    <a class="site-title" href="/">Tinix&#39;s different point of view.</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- This loops through the paginated posts -->

  <script id="dsq-count-scr" src="//tinixgit.disqus.com/count.js" async></script>


  <h1><a href="/elixir/2021/11/10/elixir-maps.html">Elixir  - Maps</a></h1>
  <p class="author">
    <span class="date">2021-11-10 18:16:18 -0300</span>
  </p>
  <div class="content">
    <h2 id="maps">Maps</h2>
<p>Whenever you need a key-value store, maps are the “go to” data structure in Elixir. A map is created using the <code class="highlighter-rouge">%{}</code> syntax:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">[</span><span class="ss">:a</span><span class="p">]</span>
<span class="mi">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="ss">:b</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">[</span><span class="ss">:c</span><span class="p">]</span>
<span class="kp">nil</span></code></pre></figure>

<p>Compared to keyword lists, we can already see two differences:</p>

<ul>
  <li>Maps allow any value as a key.</li>
  <li>Maps’ keys do not follow any ordering.</li>
</ul>

<p>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{}</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{:a =&gt; a}</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">a</span>
<span class="mi">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{:c =&gt; c}</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">MatchError</span><span class="p">)</span> <span class="n">no</span> <span class="n">match</span> <span class="n">of</span> <span class="n">right</span> <span class="n">hand</span> <span class="n">side</span> <span class="ss">value: </span><span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span></code></pre></figure>

<p>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</p>

<p>Variables can be used when accessing, matching and adding map keys:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="sx">%{n =&gt; :one}</span>
<span class="sx">%{1 =&gt; :one}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="ss">:one</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{^n =&gt; :one}</span> <span class="o">=</span> <span class="sx">%{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}</span>
<span class="sx">%{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}</span></code></pre></figure>

<p><a href="https://hexdocs.pm/elixir/Map.html">The Map module</a> provides a very similar API to the <code class="highlighter-rouge">Keyword</code> module with convenience functions to manipulate maps:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="no">Map</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span><span class="p">,</span> <span class="ss">:a</span><span class="p">)</span>
<span class="mi">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Map</span><span class="p">.</span><span class="nf">put</span><span class="p">(</span><span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span><span class="p">,</span> <span class="ss">:c</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1, :c =&gt; 3}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Map</span><span class="p">.</span><span class="nf">to_list</span><span class="p">(</span><span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span><span class="p">)</span>
<span class="p">[{</span><span class="mi">2</span><span class="p">,</span> <span class="ss">:b</span><span class="p">},</span> <span class="p">{</span><span class="ss">:a</span><span class="p">,</span> <span class="mi">1</span><span class="p">}]</span></code></pre></figure>

<p>Maps have the following syntax for updating a key’s value:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{map | 2 =&gt; "two"}</span>
<span class="sx">%{2 =&gt; "two", :a =&gt; 1}</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="sx">%{map | :c =&gt; 3}</span>
<span class="o">**</span> <span class="p">(</span><span class="no">KeyError</span><span class="p">)</span> <span class="n">key</span> <span class="ss">:c</span> <span class="n">not</span> <span class="n">found</span> <span class="ss">in: </span><span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span></code></pre></figure>

<p>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the <code class="highlighter-rouge">:c</code> key failed because there is no <code class="highlighter-rouge">:c</code> in the map.</p>

<p>When all the keys in a map are atoms, you can use the keyword syntax for convenience:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="sx">%{a: 1, b: 2}</span>
<span class="sx">%{a: 1, b: 2}</span></code></pre></figure>

<p>Another interesting property of maps is that they provide their own syntax for accessing atom keys:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="sx">%{:a =&gt; 1, 2 =&gt; :b}</span>
<span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">.</span><span class="nf">a</span>
<span class="mi">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">.</span><span class="nf">c</span>
<span class="o">**</span> <span class="p">(</span><span class="no">KeyError</span><span class="p">)</span> <span class="n">key</span> <span class="ss">:c</span> <span class="n">not</span> <span class="n">found</span> <span class="ss">in: </span><span class="sx">%{2 =&gt; :b, :a =&gt; 1}</span></code></pre></figure>

<p>Elixir developers typically prefer to use the <code class="highlighter-rouge">map.field</code> syntax and pattern matching instead of the functions in the <code class="highlighter-rouge">Map</code>  module when working with maps because they lead to an assertive style of programming. <a href="https://dashbit.co/blog/writing-assertive-code-with-elixir">This blog post by José Valim</a> provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</p>

<h3 id="nested-data-structures">Nested data structures</h3>

<p>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the <code class="highlighter-rouge">put_in/2</code> , <code class="highlighter-rouge">update_in/2</code>  and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</p>

<p>Imagine you have the following structure:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="p">[</span>
  <span class="ss">john: </span><span class="sx">%{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]}</span><span class="p">,</span>
  <span class="ss">mary: </span><span class="sx">%{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}</span>
<span class="p">]</span>
<span class="p">[</span>
  <span class="ss">john: </span><span class="sx">%{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"}</span><span class="p">,</span>
  <span class="ss">mary: </span><span class="sx">%{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}</span>
<span class="p">]</span></code></pre></figure>

<p>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">[</span><span class="ss">:john</span><span class="p">].</span><span class="nf">age</span>
<span class="mi">27</span></code></pre></figure>

<p>It happens we can also use this same syntax for updating the value:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">put_in</span> <span class="n">users</span><span class="p">[</span><span class="ss">:john</span><span class="p">].</span><span class="nf">age</span><span class="p">,</span> <span class="mi">31</span>
<span class="p">[</span>
  <span class="ss">john: </span><span class="sx">%{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"}</span><span class="p">,</span>
  <span class="ss">mary: </span><span class="sx">%{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}</span>
<span class="p">]</span></code></pre></figure>

<p>The <code class="highlighter-rouge">update_in/2</code>  macro is similar but allows us to pass a function that controls how the value changes. For example, let’s remove “Clojure” from Mary’s list of languages:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">iex</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">update_in</span> <span class="n">users</span><span class="p">[</span><span class="ss">:mary</span><span class="p">].</span><span class="nf">languages</span><span class="p">,</span> <span class="n">fn</span> <span class="n">languages</span> <span class="o">-&gt;</span> <span class="no">List</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">languages</span><span class="p">,</span> <span class="s2">"Clojure"</span><span class="p">)</span> <span class="k">end</span>
<span class="p">[</span>
  <span class="ss">john: </span><span class="sx">%{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"}</span><span class="p">,</span>
  <span class="ss">mary: </span><span class="sx">%{age: 29, languages: ["Elixir", "F#"], name: "Mary"}</span>
<span class="p">]</span></code></pre></figure>

<p>There is more to learn about <code class="highlighter-rouge">put_in/2</code>  and <code class="highlighter-rouge">update_in/2</code>, including the <code class="highlighter-rouge">get_and_update_in/2</code>  that allows us to extract a value and update the data structure at once. There are also <code class="highlighter-rouge">put_in/3</code>,  <code class="highlighter-rouge">update_in/3</code>  and <code class="highlighter-rouge">get_and_update_in/3</code>  which allow dynamic access into the data structure.</p>

<p>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</p>

  </div>

  <h1><a href="/ruby/2021/10/31/ruby-equality-tests.html">Ruby Equality tests</a></h1>
  <p class="author">
    <span class="date">2021-10-31 19:21:59 -0300</span>
  </p>
  <div class="content">
    <p>The Object class defines three equality-test methods: ==, eql?, and equal?. At the Object level, all equality-test methods do the same thing: they tell you whether two
objects are exactly the same object. Here they are in action:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Object:0x00000101258af8&gt;</span>
<span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">new</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Object:0x00000101251d70&gt;</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">a</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
<span class="o">=&gt;</span> <span class="kp">false</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">false</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">false</span></code></pre></figure>

<p>All three of the positive equality-test methods give the same results in these examples: 
when you test a against a, the result is true, and when you test a against b, the result is false. (The not-equal or negative equality test method != is the inverse of the ==
method; in fact, if you define ==, your objects will automatically have the != method.)
We have plenty of ways to establish that a is a but not b.</p>

<h5 id="but-there-isnt-much-point-in-having-three-tests-that-do-the-same-thing">But there isn’t much point in having three tests that do the same thing.</h5>
<p>Further down the road, in classes other than Object, == and/or eql? are typically redefined to do meaningful work for different objects. For example, String redefines == and eql? to return whether the value of the strings being compared are identical. Two strings
can have the same value but in fact be different objects. The equal? method retains its Object definition and checks if two strings are exactly the same object. Let’s look at string equality in action:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="n">string1</span> <span class="o">=</span> <span class="s2">"text"</span>
<span class="o">=&gt;</span> <span class="s2">"text"</span>
<span class="o">&gt;&gt;</span> <span class="n">string2</span> <span class="o">=</span> <span class="s2">"text"</span>
<span class="o">=&gt;</span> <span class="s2">"text"</span>
<span class="o">&gt;&gt;</span> <span class="n">string1</span> <span class="o">==</span> <span class="n">string2</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">string1</span><span class="p">.</span><span class="nf">eql?</span><span class="p">(</span><span class="n">string2</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="n">string1</span><span class="p">.</span><span class="nf">equal?</span><span class="p">(</span><span class="n">string2</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="kp">false</span></code></pre></figure>

<p>As you can see, the strings are == and eql?, but not equal?. Ruby recommends against redefining equal? so that it can always be used to determine object identity.</p>

<p>Why do we have == and eql? if they’re synonymous at the Object level? Because it gives us more flexibility as we subclass Object. Because we don’t redefine equal?, we
have the option to redefine either == or eql? and compare objects in different ways.</p>

<p>For example, in the Numeric class (a superclass of Integer and Float), == performs type conversion before making a comparison but eql? doesn’t:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="o">&gt;&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span><span class="o">.</span><span class="mi">0</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">.</span><span class="nf">eql?</span> <span class="mi">5</span><span class="o">.</span><span class="mi">0</span>
<span class="o">=&gt;</span> <span class="kp">false</span></code></pre></figure>

<p>Ruby gives you a suite of tools for object comparisons, and not always just comparison for equality.</p>

  </div>

  <h1><a href="/ruby/2021/10/31/ruby-rails-remember-a-method-name.html">Ruby remember a method name</a></h1>
  <p class="author">
    <span class="date">2021-10-31 01:19:49 -0300</span>
  </p>
  <div class="content">
    <p>Trying to remember a method name or just discover what you can call on an object? Ruby has you covered! Check out examples below</p>

<h4 id="list-all-methods">List all methods</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">methods</span></code></pre></figure>

<h4 id="list-all-direct-methods-except-object-class-methods">List all direct methods except Object class methods</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">methods</span> <span class="o">-</span> <span class="no">Object</span><span class="p">.</span><span class="nf">methods</span></code></pre></figure>

<h4 id="list-all-direct-methods--not-comming-from-a-parent-class-">List all direct methods ( not comming from a parent class )</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span></code></pre></figure>

<h4 id="list-all-instance-methods">List all instance methods</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">instance_methods</span></code></pre></figure>

<h4 id="list-all-direct-instance-methods">List all direct instance methods</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span></code></pre></figure>

<h4 id="list-all-methods-and-then-grep-on-them">List all methods and then grep on them</h4>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">User</span><span class="p">.</span><span class="nf">methods</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="sr">/find/</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:find_for_database_authentication</span><span class="p">,</span>
 <span class="ss">:find_for_authentication</span><span class="p">,</span>
 <span class="ss">:find_first_by_auth_conditions</span><span class="p">,</span>
 <span class="ss">:find_or_initialize_with_error_by</span><span class="p">,</span>
 <span class="ss">:find_or_initialize_with_errors</span><span class="p">,</span>
 <span class="ss">:_find_callbacks</span><span class="p">,</span>
 <span class="ss">:_find_callbacks</span><span class="o">=</span><span class="p">,</span>
 <span class="ss">:after_find</span><span class="p">,</span>
 <span class="ss">:finder_needs_type_condition?</span><span class="p">,</span>
 <span class="ss">:find_by!</span><span class="p">,</span>
 <span class="ss">:cached_find_by_statement</span><span class="p">,</span>
 <span class="ss">:find_by</span><span class="p">,</span>
 <span class="ss">:initialize_find_by_cache</span><span class="p">,</span>
 <span class="ss">:find</span><span class="p">,</span>
 <span class="ss">:find_or_create_by</span><span class="p">,</span>
 <span class="ss">:find_or_create_by!</span><span class="p">,</span>
 <span class="ss">:find_or_initialize_by</span><span class="p">,</span>
 <span class="ss">:create_or_find_by</span><span class="p">,</span>
 <span class="ss">:create_or_find_by!</span><span class="p">,</span>
 <span class="ss">:find_each</span><span class="p">,</span>
 <span class="ss">:find_in_batches</span><span class="p">,</span>
 <span class="ss">:find_by_sql</span><span class="p">]</span></code></pre></figure>

  </div>

  <h1><a href="/golang/2021/10/29/go-errors.html">Go Errors</a></h1>
  <p class="author">
    <span class="date">2021-10-29 00:19:13 -0300</span>
  </p>
  <div class="content">
    <p>In Go it’s idiomatic to communicate errors via an explicit, separate return value. This contrasts with the exceptions used in languages like Java and Ruby and the overloaded single result / error value sometimes used in C. Go’s approach makes it easy to see which functions return errors and to handle them using the same language constructs employed for any other, non-error tasks</p>

<p>By convention, errors are the last return value and have type error, a built-in interface.</p>

<p>errors.New constructs a basic error value with the given error message.</p>

<p>A nil value in the error position indicates that there was no error.</p>

<p>It’s possible to use custom types as errors by implementing the Error() method on them. Here’s a variant on the example above that uses a custom type to explicitly represent an argument error.</p>

<p>In this case we use &amp;argError syntax to build a new struct, supplying values for the two fields arg and prob.</p>

<p>The two loops below test out each of our error-returning functions. Note that the use of an inline error check on the if line is a common idiom in Go code.</p>

<p>If you want to programmatically use the data in a custom error, you’ll need to get the error as an instance of the custom error type via type assertion.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">package</span> <span class="n">main</span>

<span class="n">import</span> <span class="p">(</span>
    <span class="s2">"errors"</span>
    <span class="s2">"fmt"</span>
<span class="p">)</span>

<span class="n">func</span> <span class="n">f1</span><span class="p">(</span><span class="n">arg</span> <span class="n">int</span><span class="p">)</span> <span class="p">(</span><span class="n">int</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="mi">42</span> <span class="p">{</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">errors</span><span class="o">.</span><span class="no">New</span><span class="p">(</span><span class="s2">"can't work with 42"</span><span class="p">)</span>

    <span class="p">}</span>

    <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="kp">nil</span>
<span class="p">}</span>

<span class="n">type</span> <span class="n">argError</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">arg</span>  <span class="n">int</span>
    <span class="n">prob</span> <span class="n">string</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">argError</span><span class="p">)</span> <span class="no">Error</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="no">Sprintf</span><span class="p">(</span><span class="s2">"%d - %s"</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="nf">arg</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="nf">prob</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">f2</span><span class="p">(</span><span class="n">arg</span> <span class="n">int</span><span class="p">)</span> <span class="p">(</span><span class="n">int</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="mi">42</span> <span class="p">{</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argError</span><span class="p">{</span><span class="n">arg</span><span class="p">,</span> <span class="s2">"can't work with it"</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="kp">nil</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="p">[]</span><span class="n">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">42</span><span class="p">}</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">e</span> <span class="o">!=</span> <span class="kp">nil</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="s2">"f1 failed:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="s2">"f1 worked:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">range</span> <span class="p">[]</span><span class="n">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">42</span><span class="p">}</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">,</span> <span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">f2</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="n">e</span> <span class="o">!=</span> <span class="kp">nil</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="s2">"f2 failed:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="s2">"f2 worked:"</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">f2</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ae</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">argError</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="n">ae</span><span class="p">.</span><span class="nf">arg</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="no">Println</span><span class="p">(</span><span class="n">ae</span><span class="p">.</span><span class="nf">prob</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">$</span> <span class="n">go</span> <span class="n">run</span> <span class="n">errors</span><span class="p">.</span><span class="nf">go</span>
<span class="n">f1</span> <span class="ss">worked: </span><span class="mi">10</span>
<span class="n">f1</span> <span class="ss">failed: </span><span class="n">can</span><span class="s1">'t work with 42
f2 worked: 10
f2 failed: 42 - can'</span><span class="n">t</span> <span class="n">work</span> <span class="n">with</span> <span class="n">it</span>
<span class="mi">42</span>
<span class="n">can</span><span class="err">'</span><span class="n">t</span> <span class="n">work</span> <span class="n">with</span> <span class="n">it</span></code></pre></figure>

<p>See this <a href="http://blog.golang.org/2011/07/error-handling-and-go.html">great pos</a>t on the Go blog for more on error handling.</p>

  </div>

  <h1><a href="/ruby/2021/09/20/what-is-proc-in-ruby.html">What is Proc in Ruby</a></h1>
  <p class="author">
    <span class="date">2021-09-20 20:39:07 -0300</span>
  </p>
  <div class="content">
    <p>A Proc object is an encapsulation of a block of code, which can be stored in a local variable, passed to a method or another Proc, and can be called. Proc is an essential concept in Ruby and a core of its functional programming features.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">square</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span>

<span class="n">square</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1">#=&gt; 9</span>
<span class="c1"># shorthands:</span>
<span class="n">square</span><span class="o">.</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>      <span class="c1">#=&gt; 9</span>
<span class="n">square</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>       <span class="c1">#=&gt; 9</span></code></pre></figure>

<p>Proc objects are closures, meaning they remember and can use the entire context in which they were created.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">gen_times</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
  <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="o">*</span><span class="n">factor</span> <span class="p">}</span> <span class="c1"># remembers the value of factor at the moment of creation</span>
<span class="k">end</span>

<span class="n">times3</span> <span class="o">=</span> <span class="n">gen_times</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">times5</span> <span class="o">=</span> <span class="n">gen_times</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">times3</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>               <span class="c1">#=&gt; 36</span>
<span class="n">times5</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                <span class="c1">#=&gt; 25</span>
<span class="n">times3</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">times5</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>   <span class="c1">#=&gt; 60</span></code></pre></figure>

<h2 id="creation">Creation</h2>
<p>There are several methods to create a Proc</p>

<ul>
  <li>Use the Proc class constructor:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">proc1</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span></code></pre></figure>

<ul>
  <li>Use the Kernel#proc method as a shorthand of ::new:</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">proc2</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span></code></pre></figure>

<ul>
  <li>Receiving a block of code into proc argument (note the &amp;):</li>
  <li></li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">make_proc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">block</span>
<span class="k">end</span>

<span class="n">proc3</span> <span class="o">=</span> <span class="n">make_proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span></code></pre></figure>

<ul>
  <li>Construct a proc with lambda semantics using the Kernel#lambda method (see below for explanations about lambdas):</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">lambda1</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span></code></pre></figure>

<p>*Use the Lambda literal syntax (also constructs a proc with lambda semantics):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">lambda2</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="p">}</span></code></pre></figure>

<h2 id="lambda-and-non-lambda-semantics">Lambda and non-lambda semantics</h2>
<ul>
  <li>Procs are coming in two flavors: lambda and non-lambda (regular procs). Differences are:</li>
  <li>In lambdas, return means exit from this lambda;</li>
</ul>

<p>*In regular procs, return means exit from embracing method (and will throw LocalJumpError if invoked outside the method);</p>

<p>*In lambdas, arguments are treated in the same way as in methods: strict, with ArgumentError for mismatching argument number, and no additional argument processing;</p>

<p>*Regular procs accept arguments more generously: missing arguments are filled with nil, single Array arguments are deconstructed if the proc has multiple arguments, and there is no error raised on extra arguments</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="s2">"x=</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">, y=</span><span class="si">#{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">#=&gt; "x=1, y=2"</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>    <span class="c1">#=&gt; "x=1, y=2", array deconstructed</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>   <span class="c1">#=&gt; "x=1, y=2", extra argument discarded</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1">#=&gt; "x=1, y=", nil substituted instead of error</span>

<span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="s2">"x=</span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">, y=</span><span class="si">#{</span><span class="n">y</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="n">l</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>      <span class="c1">#=&gt; "x=1, y=2"</span>
<span class="n">l</span><span class="p">.</span><span class="nf">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>    <span class="c1"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>
<span class="n">l</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>   <span class="c1"># ArgumentError: wrong number of arguments (given 3, expected 2)</span>
<span class="n">l</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># ArgumentError: wrong number of arguments (given 1, expected 2)</span>

<span class="k">def</span> <span class="nf">test_return</span>
  <span class="o">-&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span> <span class="p">}.</span><span class="nf">call</span>      <span class="c1"># just returns from lambda into method body</span>
  <span class="nb">proc</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span> <span class="p">}.</span><span class="nf">call</span>    <span class="c1"># returns from method</span>
  <span class="k">return</span> <span class="mi">5</span>
<span class="k">end</span>

<span class="n">test_return</span> <span class="c1"># =&gt; 4, return from proc</span></code></pre></figure>

<p>Lambdas are useful as self-sufficient functions, in particular useful as arguments to higher-order functions, behaving exactly like Ruby methods.</p>

<p>Procs are useful for implementing iterators:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">test</span>
  <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]].</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="k">return</span> <span class="n">a</span> <span class="k">if</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="p">}</span>
                            <span class="c1">#  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="k">end</span></code></pre></figure>

<p>Inside map, the block of code is treated as a regular (non-lambda) proc, which means that the internal arrays will be deconstructed to pairs of arguments, and return will exit from the method test. That would not be possible with a stricter lambda.</p>

<p>You can tell a lambda from a regular proc by using the lambda? instance method.</p>

<p>Lambda semantics is typically preserved during the proc lifetime, including &amp;-deconstruction to a block of code:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">p</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="p">}</span>
<span class="n">l</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="p">}</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">p</span><span class="p">)</span> <span class="c1">#=&gt; [1, 2]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]].</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)</span> <span class="c1"># ArgumentError: wrong number of arguments (given 1, expected 2)</span></code></pre></figure>

<p>The only exception is dynamic method definition: even if defined by passing a non-lambda proc, methods still have normal semantics of argument checking.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">C</span>
  <span class="n">define_method</span><span class="p">(</span><span class="ss">:e</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">proc</span> <span class="p">{})</span>
<span class="k">end</span>
<span class="no">C</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">e</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>       <span class="c1">#=&gt; ArgumentError</span>
<span class="no">C</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:e</span><span class="p">).</span><span class="nf">to_proc</span><span class="p">.</span><span class="nf">lambda?</span>   <span class="c1">#=&gt; true</span></code></pre></figure>

<p>This exception ensures that methods never have unusual argument passing conventions, and makes it easy to have wrappers defining methods that behave as usual.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">C</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">def2</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">)</span>
    <span class="n">define_method</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">def2</span><span class="p">(</span><span class="ss">:f</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">end</span>
<span class="no">C</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>       <span class="c1">#=&gt; ArgumentError</span></code></pre></figure>

  </div>

<br>
<!--Pagination links  -->

<div class="btn btn-default">
  
  <a href="/">&laquo; Prev</a>
  

  
  
  <a href="/">1</a>
  
  
  
  <em>2</em>
  
  
  
  <a href="/page3">3</a>
  
  
  
  <a href="/page4">4</a>
  
  
  
  <a href="/page5">5</a>
  
  
  
  <a href="/page6">6</a>
  
  
  
  <a href="/page7">7</a>
  
  

  
  <a href="/page3">Next &raquo;</a>
  
</div>

<br>
<hr>
  <p class="rss-subscribe">subscribe <a href="/feed.xml">via RSS</a></p>


      </div>
    </main>
    <footer class="site-footer">
  <div class="wrapper">
    <h2 class="footer-heading">Tinix&#39;s different point of view.</h2>
    <p>Thoughts notes and other things more...</p>
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <!-- <li>Tinix&#39;s different point of view.</li> -->
          <li><a href="mailto:daniel.tinivella@gmail.com">daniel.tinivella@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">

          
          <li>
            <a href="https://github.com/Tinix"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">Tinix</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/Tinix"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">Tinix</span></a>

          </li>
          

          
          <li>
            <a href="https://gitlab.com/Tinix"><span class="icon icon--gitlab"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#30353e"/><path fill="#e24329" d="M84 215l43-133c2-7 12-7 14 0l115 353L371 82c2-7 12-7 14 0l43 133"/><path fill="#fc6d26" d="M256 435L84 215h100.4zm71.7-220H428L256 435l71.6-220z"/><path fill="#fca326" d="M84 215l-22 67c-2 6 0 13 6 16l188 137zm344 0l22 67c2 6 0 13-6 16L256 435z"/></svg></span>
  <span class="username">Tinix</span></a>

          </li>
          

        </ul>
      </div>

      <!-- Begin Stat for Default  -->
      <script type="text/javascript">
        var sc_project=9629919;
        var sc_invisible=1;
        var sc_security="fd5bb5c2";
        var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
        document.write("<sc"+"ript type='text/javascript' src='" +
          scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
      </script>
      <noscript><div class="statcounter"><a title="shopify visitor
      statistics" href="http://statcounter.com/shopify/"
                  target="_blank"><img class="statcounter"
                                       src="http://c.statcounter.com/9629919/0/fd5bb5c2/1/"
                                       alt="shopify visitor statistics"></a></div></noscript>
      <!-- End of Stat for Default -->

      <!-- Yandex.Metrika counter -->
      <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
          m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(56423338, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true
        });
      </script>
      <noscript><div><img src="https://mc.yandex.ru/watch/56423338" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
      <!-- /Yandex.Metrika counter -->
      <div class="footer-col footer-col-3">
        <p>
          &copy; 2003 - 2023 Daniel Tinivella.<br /> All rights reserved.<br/>
          DanielTinivella is powered by: <a href="http://jekyllrb.com">Jekyll</a>,<br />
          <a href="https://www.vim.org/">Vim</a> and <a href="http://disqus.com">Disqus</a>
      </div>
    </div>
  </div>
</footer>


  </body>

</html>
